#include "L1Ntuple.h"
#include "hist.C"
#include "Style.C"
#include "TMath.h"
#include "TLegend.h"
#include "TMultiGraph.h"
#include <TGraphAsymmErrors.h>
#include <TF1.h>
#include <TLorentzVector.h>
#include <algorithm>

// --------------------------------------------------------------------
//                       L1JetAnalysis macro definition
//
//    macro automatically generated by GenerateMacro.sh script
//    author           : bm409
//    creation date    : Sat Oct 23 14:00:25 CEST 2010
//    last update date :
//    description      :
//
// --------------------------------------------------------------------

class L1JetAnalysis : public L1Ntuple
{
  public :

    //constructor
  L1JetAnalysis(std::string filename) : L1Ntuple(filename) {}
  L1JetAnalysis() {}
  ~L1JetAnalysis() {}

    //main function macro : arguments can be adpated to your need
  void run(Long64_t nevents, TString outputname);

  private :
  bool PassTrig(int ib,int bx);
  bool MatchJet(int RecoJetIdx);
  std::pair <int,int> ReturnMatchedJet(int RecoJetIdx);
  int ReturnRecoObjectMatchedL1(int CenJetIndex,int Collection);
  int MaxL1Type();
  double MaxL1Et();


  void BookHistos();
  double ReturnMatchedQuantity( std::pair<int,int> matchJet,int Quantity);


  virtual double deltaPhi(double phi1, double phi2);
  virtual double deltaR(double eta1, double phi1, double eta2, double phi2);
    //your private methods can be declared here




// histos
  TH1F *RefJets;
  TH1F *SingleJet16;
  TH1F *SingleJet36;
  TH1F *SingleJet52; //your private methods can be declared here
  TH1F *SingleJet68;
  TH1F *SingleJet92;
  TH1F *SingleJet128;
  TH1F *SingleJet80_Central;
  TH1F *CandidateJets30Gev;
  TH2F *RecoVsl1HFE;
  TH2F *ResolutionEtHFE;
  TH1F *ResolutionHFE;
  TH2F *RecoVsl1HFH;
  TH2F *ResolutionEtHFH;
  TH1F *ResolutionHFH;
  TH1F *ResolutionHE;
  TH2F *ResolutionEtHE;
  TH2F *RecoVsl1HE;
  TH1F *ResolutionEE;
  TH2F *ResolutionEtEE;
  TH2F *RecoVsl1EE;
  TH1F *ResolutionHB;
  TH2F *ResolutionEtHB;
  TH2F *RecoVsl1HB;
  TH1F *ResolutionEB;
  TH2F *ResolutionEtEB;
  TH2F *RecoVsl1EB;
  TH1F *EMF;
  TH2I *timeMap;
  TH2F *ResolutionAsFnOfpT;
  TH2F *ResolutionAsFnOfeta;
};












// --------------------------------------------------------------------
//                             run function
// --------------------------------------------------------------------


void L1JetAnalysis::BookHistos() {

  RefJets              = new TH1F("RefJet", "RefJetEt",200,0.,1000);
  SingleJet16          = new TH1F("Bit15", "JetEt",200,0.,1000);
  SingleJet36          = new TH1F("Bit16", "JetEt",200,0.,1000);
  SingleJet52          = new TH1F("Bit17", "JetEt",200,0.,1000);
  SingleJet68          = new TH1F("Bit18", "JetEt",200,0.,1000);
  SingleJet92          = new TH1F("Bit19", "JetEt",200,0.,1000);
  SingleJet128         = new TH1F("Bit20", "JetEt",200,0.,1000);
  SingleJet80_Central  = new TH1F("Bit21", "JetEt",200,0.,1000);
      // CandidateJets30Gev = new TH1F("RefJet", "RefJetEt",200,0.,1000);
  RecoVsl1HFE = new TH2F(     "RecoVsl1HFE",    "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  ResolutionEtHFE = new TH2F( "ResolutionEtHFE","RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  ResolutionHFE = new TH1F(   "ResolutionHFE",  "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  RecoVsl1HFH = new TH2F(     "RecoVsl1HFH",    "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  ResolutionEtHFH = new TH2F( "ResolutionEtHFH","RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  ResolutionHFH = new TH1F(   "ResolutionHFH",  "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  ResolutionHE = new TH1F(    "ResolutionHE",   "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  ResolutionEtHE = new TH2F(  "ResolutionEtHE", "RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  RecoVsl1HE = new TH2F(      "RecoVsl1HE",     "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  ResolutionEE=  new TH1F(    "ResolutionEE",   "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  ResolutionEtEE = new TH2F(  "ResolutionEtEE", "RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  RecoVsl1EE = new TH2F(      "RecoVsl1EE",     "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  ResolutionHB = new TH1F(    "ResolutionHB",   "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  ResolutionEtHB = new TH2F(  "ResolutionEtHB", "RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  RecoVsl1HB = new TH2F(      "RecoVsl1HB",     "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  ResolutionEB = new TH1F(    "ResolutionEB",   "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  ResolutionEtEB = new TH2F(  "ResolutionEtEB", "RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  RecoVsl1EB = new TH2F(      "RecoVsl1EB",     "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  EMF = new TH1F(             "EMF","Jet[0] FEM",100,-1.,1.);
  timeMap = new TH2I("Bits", "Bunch Crossing vs trigger bit", 130, 0., 130., 10, 0., 10.);
  ResolutionAsFnOfpT = new TH2F("ResolutionAsFnOfpT"," ; L1 P_{T};(Reco Jet Et - L1 Jet Et) / Reco Jet Et",30,0.,300.,200,-10.,10.);
  ResolutionAsFnOfeta = new TH2F("ResolutionAsFnOfeta"," ; L1 #eta;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",20,-5.,5.,200,-10.,10.);

}


double L1JetAnalysis::deltaPhi(double phi1, double phi2) {
  double result = phi1 - phi2;
  while (result > TMath::Pi()) result -= 2*TMath::Pi();
  while (result <= -TMath::Pi()) result += 2*TMath::Pi();
  return result;
}

double L1JetAnalysis::deltaR(double eta1, double phi1, double eta2, double phi2) {
  double deta = eta1 - eta2;
  double dphi = deltaPhi(phi1, phi2);
  return sqrt(deta*deta + dphi*dphi);
}


bool L1JetAnalysis::MatchJet(int RecoJetIdx){

  for(unsigned int i = 0; i < l1extra_->nCenJets; i++){
    if( deltaR(recoJet_->eta[RecoJetIdx], recoJet_->phi[RecoJetIdx], l1extra_->cenJetEta[i], l1extra_->cenJetPhi[i]) <= 0.5)
    {
      return true;
    }
  }

  for(unsigned int i = 0; i < l1extra_->nTauJets; i++){
    if( deltaR(recoJet_->eta[RecoJetIdx], recoJet_->phi[RecoJetIdx], l1extra_->tauJetEta[i], l1extra_->tauJetPhi[i]) <= 0.5)
    {
      return true;
    }
  }

  for(unsigned int i = 0; i < l1extra_->nFwdJets; i++){
    if( deltaR(recoJet_->eta[RecoJetIdx], recoJet_->phi[RecoJetIdx], l1extra_->fwdJetEta[i], l1extra_->fwdJetPhi[i]) <= 0.5)
    {
      return true;
    }
  }
  return false;
}

std::pair<int,int> L1JetAnalysis::ReturnMatchedJet(int RecoJetIdx){

  for(unsigned int i = 0; i < l1extra_->nCenJets; i++){
    if( deltaR(recoJet_->eta[RecoJetIdx], recoJet_->phi[RecoJetIdx], l1extra_->cenJetEta[i], l1extra_->cenJetPhi[i]) <= 0.5)
    {
      std::pair <int,int> matchedJet(0,i);
      return matchedJet;
    }
  }

  for(unsigned int i = 0; i < l1extra_->nTauJets; i++){
    if( deltaR(recoJet_->eta[RecoJetIdx], recoJet_->phi[RecoJetIdx], l1extra_->tauJetEta[i], l1extra_->tauJetPhi[i]) <= 0.5)
    {
      std::pair <int,int> matchedJet(1,i);
      return matchedJet;
    }
  }

  for(unsigned int i = 0; i < l1extra_->nFwdJets; i++){
    if( deltaR(recoJet_->eta[RecoJetIdx], recoJet_->phi[RecoJetIdx], l1extra_->fwdJetEta[i], l1extra_->fwdJetPhi[i]) <= 0.5)
    {
      std::pair <int,int> matchedJet(2,i);
      return matchedJet;
    }
  }
  std::pair <int,int> matchedJet(-1,-1);
  return matchedJet;
}

int L1JetAnalysis::ReturnRecoObjectMatchedL1(int CenJetIndex,int Collection){

  if(Collection == 0){
    for(unsigned int i = 0; i < (recoJet_->et).size(); i++){
      if((l1extra_->cenJetEta).size() >0 && deltaR(recoJet_->eta[i], recoJet_->phi[i], l1extra_->cenJetEta[CenJetIndex], l1extra_->cenJetPhi[CenJetIndex]) <= 0.5)
      {
        return i;
        }else return -1;
      }
    }else if (Collection == 1){

      for(unsigned int i = 0; i < (recoJet_->et).size(); i++){
        if( (l1extra_->tauJetEta).size() >0 && deltaR(recoJet_->eta[i], recoJet_->phi[i], l1extra_->tauJetEta[CenJetIndex], l1extra_->tauJetPhi[CenJetIndex]) <= 0.5)
        {
          return i;
          }else return -1;
        }
      }else if ( Collection == 2 ){
        for(unsigned int i = 0; i < (recoJet_->et).size(); i++){
          if( (l1extra_->fwdJetEta).size() >0 && deltaR(recoJet_->eta[i], recoJet_->phi[i], l1extra_->fwdJetEta[CenJetIndex], l1extra_->fwdJetPhi[CenJetIndex]) <= 0.5)
          {
            return i;
            }else return -1;
          }
        }
      return -1;
   }


      int L1JetAnalysis::MaxL1Type(){

        double a = 0.;
        double b = 0.;
        double c = 0.;

      if((l1extra_->cenJetEt).size() > 0) a = l1extra_->cenJetEt[0];
      if((l1extra_->tauJetEt).size() > 0) b = l1extra_->tauJetEt[0];
      if((l1extra_->fwdJetEt).size() > 0) c = l1extra_->fwdJetEt[0];


        if(max(a,b) >c){
          return ( a >b ? 0 : 1 );
        }
        else return 2;
      }


      double L1JetAnalysis::MaxL1Et(){
        double a = 0.;
        double b = 0.;
        double c = 0.;

      if((l1extra_->cenJetEt).size() > 0) a = l1extra_->cenJetEt[0];
      if((l1extra_->tauJetEt).size() > 0) b = l1extra_->tauJetEt[0];
      if((l1extra_->fwdJetEt).size() > 0) c = l1extra_->fwdJetEt[0];
        if(max(a,b) >c){
          return ( a >b ? a : b );
        }
        else return c;
      }






      bool L1JetAnalysis::PassTrig(int bit, int bx) {
        if(bit<64) { if((gt_->tw1[bx]>>bit)&1) { return true; } else return false; }
        if(bit<128) { if((gt_->tw2[bx]>>(bit-64))&1) { return true;} else return false;}
        else { if((gt_->tt[bx]>>(bit-1000))&1) { return true;} else return false;}
      }


      double L1JetAnalysis::ReturnMatchedQuantity( std::pair<int,int> matchJet,int Quantity){
        if(Quantity == 1){
          if(matchJet.first==0){
            return l1extra_->cenJetEt[matchJet.second];
          }
          if(matchJet.first==1){
            return l1extra_->tauJetEt[matchJet.second];
          }
          if(matchJet.first ==2 ){
            return l1extra_->fwdJetEt[matchJet.second];
          }
          if(matchJet.first==-1){
            return false;}
          }

          if(Quantity==2){
            switch(matchJet.first){
              if(matchJet.first==0){
                return l1extra_->cenJetEta[matchJet.second];
              }
              if(matchJet.first==1){
                return l1extra_->tauJetEta[matchJet.second];
              }
              if(matchJet.first==2){
                return l1extra_->fwdJetEta[matchJet.second];
              }
              if(matchJet.first==-1){
                return false;
              }
            }
          }

          if(Quantity==3){
            switch(matchJet.first){
              if(matchJet.first==0){
                return l1extra_->cenJetPhi[matchJet.second];
              }
              if(matchJet.first==1){
                return l1extra_->tauJetPhi[matchJet.second];
              }
              if(matchJet.first==2){
                return l1extra_->fwdJetPhi[matchJet.second];
              }
              if(matchJet.first==-1){
                return false;
              }
            }
          }
          return false;
        }



// --------------------------------------------------------------------
//                             run function
// --------------------------------------------------------------------
        void L1JetAnalysis::run(Long64_t nevents, TString outputname) //To run use m.run(events,"SomeoutputName")
        {
  //Book Histos
          BookHistos();

  //load TDR style
          setTDRStyle();
          TFile *theFile = new TFile(outputname, "RECREATE");
          theFile->cd();
  //number of events to process
          if (nevents==-1 || nevents>GetEntries()) nevents=GetEntries();
          std::cout << nevents  << " to process ..." << std::endl;

  //loop over the events
          for (Long64_t i= 0; i<   nevents; i++)
          {
      //load the i-th event
            Long64_t ientry = LoadTree(i); if (ientry < 0) break;
            GetEntry(i);
            bool looseID;
      //process progress
            if(i!=0 && (i%10000)==0) {std::cout << "- processing event " << i << "\r" << std::flush;}
            double wgt =1.0;
      // cout << "Number of Jets: " << (recoJet_->et).size() << endl;
            if((recoJet_->et).size() < 1) continue;
      // if( !PassTrig(4,2) || !PassTrig(41,2) ) continue; // check the event passes min bias triggers
      // cout << " check bit 40 pass" << endl;
      if(!PassTrig(1040,2)) continue;
      //write your code here
      // bool looseID = ( ( recoJet_->eEMF[0]>0.01  ) &&  ( recoJet_->n90hits[0] > 1 ) && ( recoJet_->fHPD[0] < 0.98 ) ); // check leading reco jet passes looseID
      // cout << "started event selection" << endl;
      // if (!looseID) continue;
        // cout << " Passed event selection (ID && Eta && PT)" << endl;

            if(recoJet_->et[0]<2. ) continue; // || fabs(recoJet_->eta[0])>2.6) continue; // check leading recoJet is with in barrel and has et>2GeV
        // cout << " Passed event selection (ID && Eta && PT)" << endl;
      // cout << "passed event selection" << endl;
// matched jet
      // cout<<"Matched a RecoJet to a L1 Jet! " << endl;
            std::pair <int,int> matchedJet = ReturnMatchedJet(0); // Try to match a L1 Jet to the zeroth reco Jet, return the l1 type and l1 index of
            int Et = 1;
            // if(ReturnMatchedQuantity(matchedJet,Et)> 16.){ SingleJet16        ->Fill(recoJet_->et[0],wgt); } // now goes to SingleJet16
            //         if(ReturnMatchedQuantity(matchedJet,Et)> 36.){ SingleJet36        ->Fill(recoJet_->et[0],wgt); } // now goes to SingleJet36
            //         if(ReturnMatchedQuantity(matchedJet,Et)> 52.){ SingleJet52        ->Fill(recoJet_->et[0],wgt); } // now goes to SingleJet52
            //         if(ReturnMatchedQuantity(matchedJet,Et)> 68.){ SingleJet68        ->Fill(recoJet_->et[0],wgt); } // now goes to SingleJet68
            //         if(ReturnMatchedQuantity(matchedJet,Et)> 92.){ SingleJet92        ->Fill(recoJet_->et[0],wgt); } // now goes to SingleJet92
            //         if(ReturnMatchedQuantity(matchedJet,Et)> 128.){ SingleJet128      ->Fill(recoJet_->et[0],wgt); } // now goes to SingleJet128
            //         if(MatchJet(0)){RefJets->Fill(recoJet_->et[0],wgt);} // reference set of jets are those that are matched to a L1 jet, at current only check the leading offline jet.

            int j = ReturnRecoObjectMatchedL1(0,MaxL1Type());
            if (j == -1) continue;

            // looseID = ( ( recoJet_->eEMF[j]>0.01  ) &&  ( recoJet_->n90hits[j] > 1 ) && ( recoJet_->fHPD[j] < 0.98 ) ); // check leading reco jet passes looseID
            looseID = ( ( recoJet_->eEMF[0]>0.01  ) &&  ( recoJet_->n90hits[0] > 1 ) && ( recoJet_->fHPD[0] < 0.98 ) ); // check leading reco jet passes looseID

      // cout << "started event selection" << endl;
            if (!looseID) continue;


            // if(MaxL1Et() > 16.){ SingleJet16        ->Fill(recoJet_->et[j],wgt); } // now goes to SingleJet16
            // if(MaxL1Et() > 36.){ SingleJet36        ->Fill(recoJet_->et[j],wgt); } // now goes to SingleJet36
            // if(MaxL1Et() > 52.){ SingleJet52        ->Fill(recoJet_->et[j],wgt); } // now goes to SingleJet52
            // if(MaxL1Et() > 68.){ SingleJet68        ->Fill(recoJet_->et[j],wgt); } // now goes to SingleJet68
            // if(MaxL1Et() > 92.){ SingleJet92        ->Fill(recoJet_->et[j],wgt); } // now goes to SingleJet92
            // if(MaxL1Et() > 128.){ SingleJet128      ->Fill(recoJet_->et[j],wgt); } // now goes to SingleJet128
            // RefJets->Fill(recoJet_->et[j],wgt); // reference set of jets are those that are matched to a L1 jet, at current only check the leading offline jet.


        // if(ReturnMatchedQuantity(matchedJetLoop,Et) < 14.) continue;

          if(PassTrig(15,2) && MatchJet(0)){ SingleJet16        ->Fill(recoJet_->et[0],wgt); } // now goes to SingleJet16
          if(PassTrig(16,2) && MatchJet(0)){ SingleJet36        ->Fill(recoJet_->et[0],wgt); } // now goes to SingleJet36
          if(PassTrig(17,2) && MatchJet(0)){ SingleJet52        ->Fill(recoJet_->et[0],wgt); } // now goes to SingleJet52
          if(PassTrig(18,2) && MatchJet(0)){ SingleJet68        ->Fill(recoJet_->et[0],wgt); } // now goes to SingleJet68
          if(PassTrig(19,2) && MatchJet(0)){ SingleJet92        ->Fill(recoJet_->et[0],wgt); } // now goes to SingleJet92
          if(PassTrig(20,2) && MatchJet(0)){ SingleJet128       ->Fill(recoJet_->et[0],wgt); } // now goes to SingleJet128
          if(PassTrig(21,2) && MatchJet(0)){ SingleJet80_Central->Fill(recoJet_->et[0],wgt); } // now goes to SingleJet80_Central
          RefJets->Fill(recoJet_->et[0],wgt); // reference set of jets are those that are matched to a L1 jet, at current only check the leading offline jet.

          // barrel jets

            if(MaxL1Et() < 14. && MaxL1Et() > 120.) continue;
            EMF->Fill(recoJet_->eEMF[j],2);
            ResolutionAsFnOfeta->Fill(recoJet_->eta[j], (recoJet_->et[j]-MaxL1Et())/recoJet_->et[j],wgt);
            ResolutionAsFnOfeta->Fill(recoJet_->eta[j], (recoJet_->et[j]-MaxL1Et())/recoJet_->et[j],wgt);
            ResolutionAsFnOfeta->Fill(recoJet_->eta[j], (recoJet_->et[j]-MaxL1Et())/recoJet_->et[j],wgt);

            ResolutionAsFnOfpT->Fill(recoJet_->et[j], (recoJet_->et[j]-MaxL1Et())/recoJet_->et[j],wgt);
            if( fabs(recoJet_->eta[j]) < 1.3 ){
              if(recoJet_->eEMF[j] > 0.9){
                RecoVsl1EB->Fill(recoJet_->et[j],MaxL1Et(),wgt);
                ResolutionEtEB->Fill(recoJet_->et[j], (recoJet_->et[j]-MaxL1Et())/recoJet_->et[j],wgt);
                ResolutionEB->Fill((recoJet_->et[j]-MaxL1Et())/recoJet_->et[j],wgt);
              }

              if(recoJet_->eEMF[j] < 0.4){
                RecoVsl1HB->Fill(recoJet_->et[j],MaxL1Et(),wgt);
                ResolutionEtHB->Fill(recoJet_->et[j], (recoJet_->et[j]-MaxL1Et())/recoJet_->et[j],wgt);
                ResolutionHB->Fill((recoJet_->et[j]-MaxL1Et())/recoJet_->et[j],wgt);
              }
            }
              //endcap jets
            if(fabs(recoJet_->eta[j]) > 1.3 && fabs(recoJet_->eta[j]) < 3.0){
              if(recoJet_->eEMF[j] > 0.9){
                RecoVsl1EE->Fill(recoJet_->et[j],MaxL1Et(),wgt);
                ResolutionEtEE->Fill(recoJet_->et[j], (recoJet_->et[j]-MaxL1Et())/recoJet_->et[j],wgt);

                ResolutionEE->Fill((recoJet_->et[j]-MaxL1Et())/recoJet_->et[j],wgt);
              }


              if(recoJet_->eEMF[j] < 0.4){
                RecoVsl1HE->Fill(recoJet_->et[j],MaxL1Et(),wgt);
                ResolutionEtHE->Fill(recoJet_->et[j], (recoJet_->et[j]-MaxL1Et())/recoJet_->et[j],wgt);
                ResolutionHE->Fill((recoJet_->et[j]-MaxL1Et())/recoJet_->et[j],wgt);
              }

            }


      //forward jets
            if(fabs(recoJet_->eta[j]) > 3.0 ){
              if(recoJet_->eEMF[j] > 0.9){
                RecoVsl1HFE->Fill(recoJet_->et[j],MaxL1Et(),wgt);
                ResolutionEtHFE->Fill(recoJet_->et[j], (recoJet_->et[j]-MaxL1Et())/recoJet_->et[j],wgt);
                ResolutionHFE->Fill((recoJet_->et[j]-MaxL1Et())/recoJet_->et[j],wgt);
              }

              if(recoJet_->eEMF[j] < 0.4){
                RecoVsl1HFH->Fill(recoJet_->et[j],MaxL1Et(),wgt);
                ResolutionEtHFH->Fill(recoJet_->et[j], (recoJet_->et[j]-MaxL1Et())/recoJet_->et[j],wgt);
                ResolutionHFH->Fill((recoJet_->et[j]-MaxL1Et())/recoJet_->et[j],wgt);
              }

            }


      // if(recoJet_->et[0]> 16){ SingleJet80_Central->Fill(recoJet_->et[0],wgt); } // now goes to SingleJet80_Central

            looseID = ( ( recoJet_->eEMF[0]>0.01  ) &&  ( recoJet_->n90hits[0] > 1 ) && ( recoJet_->fHPD[0] < 0.98 ) ); // check leading reco jet passes looseID
      // cout << "started event selection" << endl;
            if (!looseID) continue;




            for(size_t bx = 0; bx < 5; ++bx)
            {
              for(size_t bit = 0; bit < 128; ++bit)
              {
                if(PassTrig(bit,bx)){
                  timeMap->Fill(bit,bx,wgt);
                }
              }
            }

          }

          TCanvas *c1 = new TCanvas("DrawMe","somecanvas",800,800);


          TLegend *leg  = new TLegend(0.2,0.8,.4,.9, "legend");
          TMultiGraph *JetTurnOnCurves = new TMultiGraph("Jet Turn on curves", " Jet Turn On curves");
          TGraphAsymmErrors *Jet30TurnOn = new TGraphAsymmErrors();



          TGraphAsymmErrors *SingleJet16TurnOn  = new TGraphAsymmErrors();
          TGraphAsymmErrors *SingleJet36TurnOn = new TGraphAsymmErrors();
          TGraphAsymmErrors *SingleJet52TurnOn = new TGraphAsymmErrors();
          TGraphAsymmErrors *SingleJet68TurnOn = new TGraphAsymmErrors();
          TGraphAsymmErrors *SingleJet92TurnOn = new TGraphAsymmErrors();
          TGraphAsymmErrors *SingleJet128TurnOn = new TGraphAsymmErrors();
          TGraphAsymmErrors *SingleJet80_CentralTurnOn = new TGraphAsymmErrors();

          SingleJet16TurnOn ->BayesDivide(SingleJet16        , RefJets);
          SingleJet36TurnOn->BayesDivide(SingleJet36         , RefJets);
          SingleJet52TurnOn->BayesDivide(SingleJet52         , RefJets);
          SingleJet68TurnOn->BayesDivide(SingleJet68         , RefJets);
          SingleJet92TurnOn->BayesDivide(SingleJet92         , RefJets);
          SingleJet128TurnOn->BayesDivide(SingleJet128       , RefJets);
          SingleJet80_CentralTurnOn->BayesDivide(SingleJet80_Central, RefJets);

          SingleJet16TurnOn->SetMarkerStyle( 20 );
          SingleJet16TurnOn  ->SetLineColor( 1  );
          SingleJet16TurnOn->SetMarkerColor( 1  );

          SingleJet36TurnOn->SetMarkerStyle( 21 );
          SingleJet36TurnOn  ->SetLineColor( 2  );
          SingleJet36TurnOn->SetMarkerColor( 2  );

          SingleJet52TurnOn->SetMarkerStyle( 22 );
          SingleJet52TurnOn  ->SetLineColor( 3  );
          SingleJet52TurnOn->SetMarkerColor( 3  );

          Jet30TurnOn->SetMarkerStyle( 23 );
          Jet30TurnOn  ->SetLineColor( 4  );
          Jet30TurnOn->SetMarkerColor( 4  );

          SingleJet92TurnOn->SetMarkerStyle( 24 );
          SingleJet92TurnOn  ->SetLineColor( 5  );
          SingleJet92TurnOn->SetMarkerColor( 5  );

          SingleJet128TurnOn->SetMarkerStyle( 25 );
          SingleJet128TurnOn  ->SetLineColor( 6  );
          SingleJet128TurnOn->SetMarkerColor( 6  );


          SingleJet80_CentralTurnOn->SetMarkerStyle( 26 );
          SingleJet80_CentralTurnOn  ->SetLineColor( 7  );
          SingleJet80_CentralTurnOn->SetMarkerColor( 7  );


          JetTurnOnCurves->Add(SingleJet16TurnOn  ,"lp");
          JetTurnOnCurves->Add(SingleJet36TurnOn ,"lp");
          JetTurnOnCurves->Add(SingleJet52TurnOn ,"lp");
          JetTurnOnCurves->Add(SingleJet68TurnOn ,"lp");
          JetTurnOnCurves->Add(SingleJet92TurnOn ,"lp");
          JetTurnOnCurves->Add(SingleJet128TurnOn ,"lp");
          JetTurnOnCurves->Add(SingleJet80_CentralTurnOn ,"lp");

          leg->AddEntry(SingleJet16TurnOn ,"Jet16 ","lP");
          leg->AddEntry(SingleJet36TurnOn ,"Jet36" ,"lP");
          leg->AddEntry(SingleJet52TurnOn ,"Jet52" ,"lP");
          leg->AddEntry(SingleJet68TurnOn ,"Jet68" ,"lP");
          leg->AddEntry(SingleJet92TurnOn ,"Jet92" ,"lP");
          leg->AddEntry(SingleJet128TurnOn,"Jet128","lP");
          leg->AddEntry(SingleJet80_CentralTurnOn,"CentralJet80","lP");



          gPad->SetGridx(); gPad->SetGridy();
          JetTurnOnCurves->Draw("a p");
          JetTurnOnCurves->GetXaxis()->SetTitle("Jet Offline Et GeV");
          JetTurnOnCurves->GetYaxis()->SetTitle("Efficiency");

          leg->Draw();
          c1->Write();
          c1->cd();
          c1->Clear();
          leg->Clear();
          gPad->SetGridx(0); gPad->SetGridy(0);
          timeMap->Write();
          ResolutionHE->Write();
          ResolutionEtHE->Write();
          RecoVsl1HE->Write();
          ResolutionEE->Write();
          ResolutionEtEE->Write();
          RecoVsl1EE->Write();
          ResolutionHB->Write();
          ResolutionEtHB->Write();
          RecoVsl1HB->Write();
          ResolutionEB->Write();
          ResolutionEtEB->Write();
          RecoVsl1EB->Write();
          EMF->Write();
          ResolutionHFH->Write();
          ResolutionEtHFH->Write();
          RecoVsl1HFH->Write();
          ResolutionHFE->Write();
          ResolutionEtHFE->Write();
          RecoVsl1HFE->Write();
          SingleJet16->Write();
          SingleJet36->Write();
          SingleJet52->Write();
          SingleJet68->Write();
          SingleJet92->Write();
          SingleJet128->Write();
          SingleJet80_Central->Write();
          RefJets->Write();
          ResolutionAsFnOfpT->Write();
          ResolutionAsFnOfeta->Write();


          theFile->Write();
          theFile->Close();
        }
