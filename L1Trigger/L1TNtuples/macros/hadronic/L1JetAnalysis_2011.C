#include "L1Ntuple.h"
#include "hist.C"
#include "Style.C"
#include "TMath.h"
#include "TLegend.h"
#include "TMultiGraph.h"
#include <TGraphAsymmErrors.h>
#include <TF1.h>
#include <TLorentzVector.h>

// --------------------------------------------------------------------
//                       L1JetAnalysis_2011 macro definition
//
//    macro automatically generated by GenerateMacro.sh script
//    author           : bm409
//    creation date    : Sat Oct 23 14:00:25 CEST 2010
//    last update date :
//    description      :
//
// --------------------------------------------------------------------

class L1JetAnalysis_2011 : public L1Ntuple
{
  public :

    //constructor
  L1JetAnalysis_2011(std::string filename) : L1Ntuple(filename) {}
  L1JetAnalysis_2011() {}
  ~L1JetAnalysis_2011() {}

    //main function macro : arguments can be adpated to your need
  void run(Long64_t nevents, TString outputname);

  private :
  bool PassTrig(int ib,int bx);
  bool MatchJet(int RecoJetIdx);
  std::pair <int,int> ReturnMatchedJet(int RecoJetIdx);


  void BookHistos();
  double ReturnMatchedQuantity( std::pair<int,int> matchJet,int Quantity);


  virtual double deltaPhi(double phi1, double phi2);
  virtual double deltaR(double eta1, double phi1, double eta2, double phi2);
    //your private methods can be declared here




// histos
  TH1F *RefJets;
  TH1F *Bit15;
  TH1F *Bit16;
  TH1F *Bit17;
  TH1F *Bit18;
  TH1F *Bit19;
  TH1F *Bit20;
  TH1F *Bit21;
  TH1F *CandidateJets30Gev;
  TH2F *RecoVsl1HFE;
  TH2F *ResolutionEtHFE;
  TH1F *ResolutionHFE;
  TH2F *RecoVsl1HFH;
  TH2F *ResolutionEtHFH;
  TH1F *ResolutionHFH;
  TH1F *ResolutionHE;
  TH2F *ResolutionEtHE;
  TH2F *RecoVsl1HE;
  TH1F *ResolutionEE;
  TH2F *ResolutionEtEE;
  TH2F *RecoVsl1EE;
  TH1F *ResolutionHB;
  TH2F *ResolutionEtHB;
  TH2F *RecoVsl1HB;
  TH1F *ResolutionEB;
  TH2F *ResolutionEtEB;
  TH2F *RecoVsl1EB;
  TH1F *EMF;
  TH2I *timeMap;
  TH2F *ResolutionAsFnOfpT;
  TH2F *ResolutionAsFnOfeta;
};


// --------------------------------------------------------------------
//                             run function
// --------------------------------------------------------------------


void L1JetAnalysis_2011::BookHistos() {

  RefJets = new TH1F("RefJet", "RefJetEt",1000,0.,1000);
  Bit15  = new TH1F("Bit15", "JetEt",1000,0.,1000);
  Bit16  = new TH1F("Bit16", "JetEt",1000,0.,1000);
  Bit17  = new TH1F("Bit17", "JetEt",1000,0.,1000);
  Bit18  = new TH1F("Bit18", "JetEt",1000,0.,1000);
  Bit19  = new TH1F("Bit19", "JetEt",1000,0.,1000);
  Bit20  = new TH1F("Bit20", "JetEt",1000,0.,1000);
  Bit21  = new TH1F("Bit21", "JetEt",1000,0.,1000);
      // CandidateJets30Gev = new TH1F("RefJet", "RefJetEt",200,0.,1000);
  RecoVsl1HFE = new TH2F(     "RecoVsl1HFE",    "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  ResolutionEtHFE = new TH2F( "ResolutionEtHFE","RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  ResolutionHFE = new TH1F(   "ResolutionHFE",  "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  RecoVsl1HFH = new TH2F(     "RecoVsl1HFH",    "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  ResolutionEtHFH = new TH2F( "ResolutionEtHFH","RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  ResolutionHFH = new TH1F(   "ResolutionHFH",  "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  ResolutionHE = new TH1F(    "ResolutionHE",   "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  ResolutionEtHE = new TH2F(  "ResolutionEtHE", "RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  RecoVsl1HE = new TH2F(      "RecoVsl1HE",     "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  ResolutionEE=  new TH1F(    "ResolutionEE",   "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  ResolutionEtEE = new TH2F(  "ResolutionEtEE", "RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  RecoVsl1EE = new TH2F(      "RecoVsl1EE",     "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  ResolutionHB = new TH1F(    "ResolutionHB",   "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  ResolutionEtHB = new TH2F(  "ResolutionEtHB", "RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  RecoVsl1HB = new TH2F(      "RecoVsl1HB",     "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  ResolutionEB = new TH1F(    "ResolutionEB",   "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  ResolutionEtEB = new TH2F(  "ResolutionEtEB", "RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  RecoVsl1EB = new TH2F(      "RecoVsl1EB",     "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  EMF = new TH1F(             "EMF","Jet[0] FEM",100,-1.,1.);
  timeMap = new TH2I("Bits", "Bunch Crossing vs trigger bit", 130, 0., 130., 10, 0., 10.);
  ResolutionAsFnOfpT = new TH2F("ResolutionAsFnOfpT"," ; L1 P_{T};(Reco Jet Et - L1 Jet Et) / Reco Jet Et",30,0.,300.,200,-10.,10.);
  ResolutionAsFnOfeta = new TH2F("ResolutionAsFnOfeta"," ; L1 #eta;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",20,-5.,5.,200,-10.,10.);

}


double L1JetAnalysis_2011::deltaPhi(double phi1, double phi2) {
  double result = phi1 - phi2;
  while (result > TMath::Pi()) result -= 2*TMath::Pi();
  while (result <= -TMath::Pi()) result += 2*TMath::Pi();
  return result;
}

double L1JetAnalysis_2011::deltaR(double eta1, double phi1, double eta2, double phi2) {
  double deta = eta1 - eta2;
  double dphi = deltaPhi(phi1, phi2);
  return sqrt(deta*deta + dphi*dphi);
}


bool L1JetAnalysis_2011::MatchJet(int RecoJetIdx){

  for(unsigned int i = 0; i < l1extra_->nCenJets; i++){
    if( deltaR(recoJet_->eta[RecoJetIdx], recoJet_->phi[RecoJetIdx], l1extra_->cenJetEta[i], l1extra_->cenJetPhi[i]) <= 0.5)
    {
      return true;
    }
  }

  for(unsigned int i = 0; i < l1extra_->nTauJets; i++){
    if( deltaR(recoJet_->eta[RecoJetIdx], recoJet_->phi[RecoJetIdx], l1extra_->tauJetEta[i], l1extra_->tauJetPhi[i]) <= 0.5)
    {
      return true;
    }
  }

  for(unsigned int i = 0; i < l1extra_->nFwdJets; i++){
    if( deltaR(recoJet_->eta[RecoJetIdx], recoJet_->phi[RecoJetIdx], l1extra_->fwdJetEta[i], l1extra_->fwdJetPhi[i]) <= 0.5)
    {
      return true;
    }
  }
  return false;
}

std::pair<int,int> L1JetAnalysis_2011::ReturnMatchedJet(int RecoJetIdx){

  for(unsigned int i = 0; i < l1extra_->nCenJets; i++){
    if( deltaR(recoJet_->eta[RecoJetIdx], recoJet_->phi[RecoJetIdx], l1extra_->cenJetEta[i], l1extra_->cenJetPhi[i]) <= 0.5)
    {
      std::pair <int,int> matchedJet(0,i);
      return matchedJet;
    }
  }

  for(unsigned int i = 0; i < l1extra_->nTauJets; i++){
    if( deltaR(recoJet_->eta[RecoJetIdx], recoJet_->phi[RecoJetIdx], l1extra_->tauJetEta[i], l1extra_->tauJetPhi[i]) <= 0.5)
    {
      std::pair <int,int> matchedJet(1,i);
      return matchedJet;
    }
  }

  for(unsigned int i = 0; i < l1extra_->nFwdJets; i++){
    if( deltaR(recoJet_->eta[RecoJetIdx], recoJet_->phi[RecoJetIdx], l1extra_->fwdJetEta[i], l1extra_->fwdJetPhi[i]) <= 0.5)
    {
      std::pair <int,int> matchedJet(2,i);
      return matchedJet;
    }
  }
  std::pair <int,int> matchedJet(-1,-1);
  return matchedJet;
}

// int L1JetAnalysis_2011::ReturnCenJetMatchedRecoObject(int CenJetIndex){
//
//   for(unsigned int i = 0; i < (recoJet_->et).size(); i++){
//     if( deltaR(recoJet_->eta[i], recoJet_->phi[i], l1extra_->cenJetEta[CenJetIndex], l1extra_->cenJetPhi[CenJetIndex]) <= 0.5)
//     {
//       return i;
//     }
//   }
// }
//
// int L1JetAnalysis_2011::ReturnTauJetMatchedRecoObject(int CenJetIndex){
//
//   for(unsigned int i = 0; i < (recoJet_->et).size(); i++){
//     if( deltaR(recoJet_->eta[i], recoJet_->phi[i], l1extra_->tauJetEta[CenJetIndex], l1extra_->tauJetPhi[CenJetIndex]) <= 0.5)
//     {
//       return i;
//     }
//   }
// }
//
// int L1JetAnalysis_2011::ReturnFwdJetMatchedRecoObject(int CenJetIndex){
//   for(unsigned int i = 0; i < (recoJet_->et).size(); i++){
//     if( deltaR(recoJet_->eta[i], recoJet_->phi[i], l1extra_->fwdJetEta[CenJetIndex], l1extra_->fwdJettPhi[CenJetIndex]) <= 0.5)
//     {
//       return i;
//     }
//   }
// }





bool L1JetAnalysis_2011::PassTrig(int bit, int bx) {
  if(bit<64) { if((gt_->tw1[bx]>>bit)&1) { return true; } else return false; }
  if(bit<128) { if((gt_->tw2[bx]>>(bit-64))&1) { return true;} else return false;}
  else { if((gt_->tt[bx]>>(bit-1000))&1) { return true;} else return false;}
}


double L1JetAnalysis_2011::ReturnMatchedQuantity( std::pair<int,int> matchJet,int Quantity){
  if(Quantity == 1){
    if(matchJet.first==0){
      return l1extra_->cenJetEt[matchJet.second];
    }
    if(matchJet.first==1){
      return l1extra_->tauJetEt[matchJet.second];
    }
    if(matchJet.first ==2 ){
      return l1extra_->fwdJetEt[matchJet.second];
    }
    if(matchJet.first==-1){
      return false;}
    }

    if(Quantity==2){
      switch(matchJet.first){
        if(matchJet.first==0){
          return l1extra_->cenJetEta[matchJet.second];
        }
        if(matchJet.first==1){
          return l1extra_->tauJetEta[matchJet.second];
        }
        if(matchJet.first==2){
          return l1extra_->fwdJetEta[matchJet.second];
        }
        if(matchJet.first==-1){
          return false;
        }
      }
    }

    if(Quantity==3){
      switch(matchJet.first){
        if(matchJet.first==0){
          return l1extra_->cenJetPhi[matchJet.second];
        }
        if(matchJet.first==1){
          return l1extra_->tauJetPhi[matchJet.second];
        }
        if(matchJet.first==2){
          return l1extra_->fwdJetPhi[matchJet.second];
        }
        if(matchJet.first==-1){
          return false;
        }
      }
    }
    return false;
  }



// --------------------------------------------------------------------
//                             run function
// --------------------------------------------------------------------
  void L1JetAnalysis_2011::run(Long64_t nevents, TString outputname) //To run use m.run(events,"SomeoutputName")
  {
  //Book Histos
    BookHistos();

  //load TDR style
    setTDRStyle();
    TFile *theFile = new TFile(outputname, "RECREATE");
    theFile->cd();
  //number of events to process
    if (nevents==-1 || nevents>GetEntries()) nevents=GetEntries();
    std::cout << nevents  << " to process ..." << std::endl;

  //loop over the events
    for (Long64_t i= 0; i<   nevents; i++)
    {
      //load the i-th event
      Long64_t ientry = LoadTree(i); if (ientry < 0) break;
      GetEntry(i);
      //process progress
      if(i!=0 && (i%10000)==0) {std::cout << "- processing event " << i << "\r" << std::flush;}
      double wgt =1.0;
      if((recoJet_->et).size() < 1) continue;

      // if(!PassTrig(1040,2)) continue;
      // for(unsigned int t = 0; t < event_->hlt.size(); ++t){
      //  cout << event_->hlt[t] << endl;
      // }
     // bool minbias = std::find(event_->hlt.begin(),event_->hlt.end(),"HLT_L1Tech_BSC_minBias_threshold1_v1")!=event_->hlt.end();
    // if(!minbias) continue;
      //write your code here
      bool looseID;
      looseID = ( ( recoJet_->eEMF[0]>0.01  ) &&  ( recoJet_->n90hits[0] > 1 ) && ( recoJet_->fHPD[0] < 0.98 ) ); // check leading reco jet passes looseID
      // cout << "started event selection" << endl;
      if (!looseID) continue;
        // cout << " Passed event selection (ID && Eta && PT)" << endl;

      if(recoJet_->etCorr[0]<2.|| fabs(recoJet_->eta[0])>2.6) continue; // check leading recoJet is with in barrel and has et>2GeV
      // cout << " Passed event selection (ID && Eta && PT)" << endl;
      // cout << "passed event selection" << endl;
      // matched jet
      // cout<<"Matched a RecoJet to a L1 Jet! " << endl;
      std::pair <int,int> matchedJet = ReturnMatchedJet(0); // Try to match a L1 Jet to the zeroth reco Jet, return the l1 type and l1 index of
      int Et = 1;

     if(ReturnMatchedQuantity(matchedJet,Et)> 16.){ Bit15      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet16
     if(ReturnMatchedQuantity(matchedJet,Et)> 20.){ Bit16      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet36
     if(ReturnMatchedQuantity(matchedJet,Et)> 36.){ Bit17      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet52
     if(ReturnMatchedQuantity(matchedJet,Et)> 52.){ Bit18      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet68
     if(ReturnMatchedQuantity(matchedJet,Et)> 68.){ Bit19      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet92
     if(ReturnMatchedQuantity(matchedJet,Et)> 92.){ Bit20      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet128


      if(MatchJet(0)){RefJets->Fill(recoJet_->etCorr[0],wgt);} // reference set of jets are those that are matched to a L1 jet, at current only check the leading offline jet.


for(size_t j = 0 ; j < recoJet_->et.size(); ++j)
{

      std::pair <int,int> matchedJetLoop = ReturnMatchedJet(i); // Try to match a L1 Jet to the ith reco Jet, return the l1 type and l1 index of
      looseID = ( ( recoJet_->eEMF[j]>0.01  ) &&  ( recoJet_->n90hits[j] > 1 ) && ( recoJet_->fHPD[j] < 0.98 ) ); // check leading reco jet passes

      if (!looseID) continue;
      if( MatchJet(j) ){
          // barrel jets
        EMF->Fill(recoJet_->eEMF[j],2);
        ResolutionAsFnOfeta->Fill(recoJet_->eta[j], (recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
        ResolutionAsFnOfpT->Fill(recoJet_->etCorr[j], (recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);

        if( fabs(recoJet_->eta[j]) < 1.3 ){
          if(recoJet_->eEMF[j] > 0.9){
            RecoVsl1EB->Fill(recoJet_->etCorr[j],ReturnMatchedQuantity(matchedJetLoop,Et),wgt);
            ResolutionEtEB->Fill(recoJet_->etCorr[j], (recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
            ResolutionEB->Fill((recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
          }

          if(recoJet_->eEMF[j] < 0.4){
            RecoVsl1HB->Fill(recoJet_->etCorr[j],ReturnMatchedQuantity(matchedJetLoop,Et),wgt);
            ResolutionEtHB->Fill(recoJet_->etCorr[j], (recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
            ResolutionHB->Fill((recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
          }
        }
              //endcap jets
        if(fabs(recoJet_->eta[j]) > 1.3 && fabs(recoJet_->eta[j]) < 3.0){
          if(recoJet_->eEMF[j] > 0.9){
            RecoVsl1EE->Fill(recoJet_->etCorr[j],ReturnMatchedQuantity(matchedJetLoop,Et),wgt);
            ResolutionEtEE->Fill(recoJet_->etCorr[j], (recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);

            ResolutionEE->Fill((recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
          }


          if(recoJet_->eEMF[j] < 0.4){
            RecoVsl1HE->Fill(recoJet_->etCorr[j],ReturnMatchedQuantity(matchedJetLoop,Et),wgt);
            ResolutionEtHE->Fill(recoJet_->etCorr[j], (recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
            ResolutionHE->Fill((recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
          }

        }


      //forward jets
        if(fabs(recoJet_->eta[j]) > 3.0 ){
          if(recoJet_->eEMF[j] > 0.9){
            RecoVsl1HFE->Fill(recoJet_->etCorr[j],ReturnMatchedQuantity(matchedJet,Et),wgt);
            ResolutionEtHFE->Fill(recoJet_->etCorr[j], (recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJet,Et))/recoJet_->etCorr[j],wgt);
            ResolutionHFE->Fill((recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJet,Et))/recoJet_->etCorr[j],wgt);
          }

          if(recoJet_->eEMF[j] < 0.4){
            RecoVsl1HFH->Fill(recoJet_->etCorr[j],ReturnMatchedQuantity(matchedJet,Et),wgt);
            ResolutionEtHFH->Fill(recoJet_->etCorr[j], (recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJet,Et))/recoJet_->etCorr[j],wgt);
            ResolutionHFH->Fill((recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJet,Et))/recoJet_->etCorr[j],wgt);
          }

        }

      }

}





      for(size_t bx = 0; bx < 5; ++bx)
      {
        for(size_t bit = 0; bit < 128; ++bit)
        {
          if(PassTrig(bit,bx)){
            timeMap->Fill(bit,bx,wgt);
          }
        }
      }

    }

    TCanvas *c1 = new TCanvas("DrawMe","somecanvas",800,800);


    TLegend *leg  = new TLegend(0.2,0.8,.4,.9, "legend");
    TMultiGraph *JetTurnOnCurves = new TMultiGraph("Jet Turn on curves", " Jet Turn On curves");
    TGraphAsymmErrors *Jet30TurnOn = new TGraphAsymmErrors();



    TGraphAsymmErrors *SingleJet16TurnOn  = new TGraphAsymmErrors();
    TGraphAsymmErrors *SingleJet36TurnOn = new TGraphAsymmErrors();
    TGraphAsymmErrors *SingleJet52TurnOn = new TGraphAsymmErrors();
    TGraphAsymmErrors *SingleJet68TurnOn = new TGraphAsymmErrors();
    TGraphAsymmErrors *SingleJet92TurnOn = new TGraphAsymmErrors();
    TGraphAsymmErrors *SingleJet128TurnOn = new TGraphAsymmErrors();
    TGraphAsymmErrors *SingleJet80_CentralTurnOn = new TGraphAsymmErrors();

    SingleJet16TurnOn ->BayesDivide(Bit15       , RefJets);
    SingleJet36TurnOn->BayesDivide( Bit16        , RefJets);
    SingleJet52TurnOn->BayesDivide( Bit17        , RefJets);
    SingleJet68TurnOn->BayesDivide( Bit18        , RefJets);
    SingleJet92TurnOn->BayesDivide( Bit19        , RefJets);
    SingleJet128TurnOn->BayesDivide(Bit20       , RefJets);
    SingleJet80_CentralTurnOn->BayesDivide(Bit21, RefJets);

    SingleJet16TurnOn->SetMarkerStyle( 20 );
    SingleJet16TurnOn  ->SetLineColor( 1  );
    SingleJet16TurnOn->SetMarkerColor( 1  );

    SingleJet36TurnOn->SetMarkerStyle( 21 );
    SingleJet36TurnOn  ->SetLineColor( 2  );
    SingleJet36TurnOn->SetMarkerColor( 2  );

    SingleJet52TurnOn->SetMarkerStyle( 22 );
    SingleJet52TurnOn  ->SetLineColor( 3  );
    SingleJet52TurnOn->SetMarkerColor( 3  );

    Jet30TurnOn->SetMarkerStyle( 23 );
    Jet30TurnOn  ->SetLineColor( 4  );
    Jet30TurnOn->SetMarkerColor( 4  );

    SingleJet92TurnOn->SetMarkerStyle( 24 );
    SingleJet92TurnOn  ->SetLineColor( 5  );
    SingleJet92TurnOn->SetMarkerColor( 5  );

    SingleJet128TurnOn->SetMarkerStyle( 25 );
    SingleJet128TurnOn  ->SetLineColor( 6  );
    SingleJet128TurnOn->SetMarkerColor( 6  );


    SingleJet80_CentralTurnOn->SetMarkerStyle( 26 );
    SingleJet80_CentralTurnOn  ->SetLineColor( 7  );
    SingleJet80_CentralTurnOn->SetMarkerColor( 7  );


    JetTurnOnCurves->Add(SingleJet16TurnOn  ,"lp");
    JetTurnOnCurves->Add(SingleJet36TurnOn ,"lp");
    JetTurnOnCurves->Add(SingleJet52TurnOn ,"lp");
    JetTurnOnCurves->Add(SingleJet68TurnOn ,"lp");
    JetTurnOnCurves->Add(SingleJet92TurnOn ,"lp");
    JetTurnOnCurves->Add(SingleJet128TurnOn ,"lp");
    JetTurnOnCurves->Add(SingleJet80_CentralTurnOn ,"lp");

    leg->AddEntry(SingleJet16TurnOn ,"Jet16 ","lP");
    leg->AddEntry(SingleJet36TurnOn ,"Jet36" ,"lP");
    leg->AddEntry(SingleJet52TurnOn ,"Jet52" ,"lP");
    leg->AddEntry(SingleJet68TurnOn ,"Jet68" ,"lP");
    leg->AddEntry(SingleJet92TurnOn ,"Jet92" ,"lP");
    leg->AddEntry(SingleJet128TurnOn,"Jet128","lP");
    leg->AddEntry(SingleJet80_CentralTurnOn,"CentralJet80","lP");



    gPad->SetGridx(); gPad->SetGridy();
    JetTurnOnCurves->Draw("a p");
    JetTurnOnCurves->GetXaxis()->SetTitle("Jet Offline Et GeV");
    JetTurnOnCurves->GetYaxis()->SetTitle("Efficiency");

    leg->Draw();
    c1->Write();
    c1->cd();
    c1->Clear();
    leg->Clear();
    gPad->SetGridx(0); gPad->SetGridy(0);
    timeMap->Write();
    ResolutionHE->Write();
    ResolutionEtHE->Write();
    RecoVsl1HE->Write();
    ResolutionEE->Write();
    ResolutionEtEE->Write();
    RecoVsl1EE->Write();
    ResolutionHB->Write();
    ResolutionEtHB->Write();
    RecoVsl1HB->Write();
    ResolutionEB->Write();
    ResolutionEtEB->Write();
    RecoVsl1EB->Write();
    EMF->Write();
    ResolutionHFH->Write();
    ResolutionEtHFH->Write();
    RecoVsl1HFH->Write();
    ResolutionHFE->Write();
    ResolutionEtHFE->Write();
    RecoVsl1HFE->Write();
    Bit15->Write();
    Bit16->Write();
    Bit17->Write();
    Bit18->Write();
    Bit19->Write();
    Bit20->Write();
    Bit21->Write();
    RefJets->Write();
    ResolutionAsFnOfpT->Write();
    ResolutionAsFnOfeta->Write();


    theFile->Write();
    theFile->Close();
  }
